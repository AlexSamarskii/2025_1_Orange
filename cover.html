
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ResuMatch/internal/transport/http/applicant.go (0.0%)</option>
				
				<option value="file1">ResuMatch/internal/transport/http/auth.go (0.0%)</option>
				
				<option value="file2">ResuMatch/internal/transport/http/employer.go (0.0%)</option>
				
				<option value="file3">ResuMatch/internal/transport/http/resume.go (82.9%)</option>
				
				<option value="file4">ResuMatch/internal/transport/http/utils/error.go (0.0%)</option>
				
				<option value="file5">ResuMatch/internal/transport/http/utils/session.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "ResuMatch/internal/config"
        "ResuMatch/internal/entity"
        "ResuMatch/internal/entity/dto"
        "ResuMatch/internal/middleware"
        "ResuMatch/internal/transport/http/utils"
        "ResuMatch/internal/usecase"
        "encoding/json"
        "io"
        "net/http"
        "strconv"
)

type ApplicantHandler struct {
        auth      usecase.Auth
        applicant usecase.Applicant
        static    usecase.Static
        cfg       config.CSRFConfig
}

func NewApplicantHandler(auth usecase.Auth, applicant usecase.Applicant, static usecase.Static, cfg config.CSRFConfig) ApplicantHandler <span class="cov0" title="0">{
        return ApplicantHandler{auth: auth, applicant: applicant, static: static, cfg: cfg}
}</span>

func (h *ApplicantHandler) Configure(r *http.ServeMux) <span class="cov0" title="0">{
        applicantMux := http.NewServeMux()

        applicantMux.HandleFunc("POST /register", h.Register)
        applicantMux.HandleFunc("POST /login", h.Login)
        applicantMux.HandleFunc("GET /profile/{id}", h.GetProfile)
        applicantMux.HandleFunc("PUT /profile", h.UpdateProfile)
        applicantMux.HandleFunc("POST /avatar", h.UploadAvatar)

        r.Handle("/applicant/", http.StripPrefix("/applicant", applicantMux))
}</span>

// Register godoc
// @Tags Applicant
// @Summary Регистрация соискателя
// @Accept json
// @Produce json
// @Param registerData body dto.ApplicantRegister true "Данные для регистрации"
// @Header 200 {string} Set-Cookie "Сессионные cookies"
// @Header 200 {string} X-CSRF-Token "CSRF-токен"
// @Success 200 {object} dto.AuthResponse
// @Failure 400 {object} utils.APIError "Неверный формат запроса"
// @Failure 409 {object} utils.APIError "Пользователь уже существует"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /applicant/register [post]
// @Security csrf_token
func (h *ApplicantHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var registerDTO dto.ApplicantRegister
        if err := json.NewDecoder(r.Body).Decode(&amp;registerDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">applicantID, err := h.applicant.Register(ctx, &amp;registerDTO)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err := utils.CreateSession(w, r, h.auth, applicantID, "applicant"); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">middleware.SetCSRFToken(w, r, h.cfg)

        w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(dto.AuthResponse{UserID: applicantID, Role: "applicant"}); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// Login godoc
// @Tags Applicant
// @Summary Авторизация соискателя
// @Description Авторизация соискателя. При успешной авторизации отправляет куки с сессией.
// Если пользователь уже авторизован, предыдущие cookies с сессией перезаписываются.
// Также устанавливает CSRF-токен при успешной авторизации.
// @Accept json
// @Produce json
// @Param loginData body dto.Login true "Данные для авторизации (email и пароль)"
// @Header 200 {string} Set-Cookie "Сессионные cookies"
// @Header 200 {string} X-CSRF-Token "CSRF-токен"
// @Success 200 {object} dto.AuthResponse
// @Failure 400 {object} utils.APIError "Неверный формат запроса"
// @Failure 403 {object} utils.APIError "Доступ запрещен (неверные учетные данные)"
// @Failure 404 {object} utils.APIError "Пользователь не найден"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /applicant/login [post]
// @Security csrf_token
func (h *ApplicantHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var loginDTO dto.Login
        if err := json.NewDecoder(r.Body).Decode(&amp;loginDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">applicantID, err := h.applicant.Login(ctx, &amp;loginDTO)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err := utils.CreateSession(w, r, h.auth, applicantID, "applicant"); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">middleware.SetCSRFToken(w, r, h.cfg)

        w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(dto.AuthResponse{UserID: applicantID, Role: "applicant"}); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// GetProfile godoc
// @Tags Applicant
// @Summary Получить профиль соискателя
// @Description Возвращает профиль соискателя по ID. Требует авторизации. Доступен только для владельца профиля.
// @Produce json
// @Param id path int true "ID соискателя"
// @Success 200 {object} dto.ApplicantProfileResponse "Профиль соискателя"
// @Failure 400 {object} utils.APIError "Неверный ID"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 403 {object} utils.APIError "Нет доступа к этому профилю"
// @Failure 404 {object} utils.APIError "Профиль не найден"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /applicant/profile/{id} [get]
// @Security session_cookie
func (h *ApplicantHandler) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        // проверяем сессию
        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">_, _, err = h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">requestedID := r.PathValue("id")
        applicantID, err := strconv.Atoi(requestedID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        //if applicantID != currentUserID || role != "applicant" {
        //        utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
        //        return
        //}

        <span class="cov0" title="0">applicant, err := h.applicant.GetUser(ctx, applicantID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err = json.NewEncoder(w).Encode(applicant); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// UpdateProfile godoc
// @Tags Applicant
// @Summary Обновить профиль соискателя
// @Description Обновляет данные профиля соискателя, кроме аватара. Требует авторизации.
// @Accept json
// @Param updateData body dto.ApplicantProfileUpdate true "Данные для обновления профиля"
// @Success 204
// @Failure 400 {object} utils.APIError "Неверный формат данных"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 403 {object} utils.APIError "Нет доступа"
// @Failure 409 {object} utils.APIError "Пользователь уже существует"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /applicant/profile [put]
// @Security csrf_token
// @Security session_cookie
func (h *ApplicantHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        // проверяем сессию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if role != "applicant" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        <span class="cov0" title="0">var applicantDTO dto.ApplicantProfileUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;applicantDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.applicant.UpdateProfile(ctx, userID, &amp;applicantDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// UploadAvatar godoc
// @Tags Applicant
// @Summary Загрузить аватар
// @Description Загружает изображение аватара для профиля соискателя. Требует авторизации и CSRF-токена.
// @Accept multipart/form-data
// @Produce json
// @Param avatar formData file true "Файл изображения (JPEG/PNG, макс. 5MB)"
// @Success 200 {object} dto.UploadStaticResponse "Информация о файле"
// @Failure 400 {object} utils.APIError "Неверный формат файла"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 403 {object} utils.APIError "Доступ запрещен"
// @Failure 413 {object} utils.APIError "Файл слишком большой"
// @Failure 500 {object} utils.APIError "Ошибка загрузки файла"
// @Router /applicant/avatar [post]
// @Security session_cookie
// @Security csrf_token
func (h *ApplicantHandler) UploadAvatar(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        // проверяем сессию
        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if role != "applicant" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
        }</span>

        <span class="cov0" title="0">file, _, err := r.FormFile("avatar")
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
        <span class="cov0" title="0">if err = file.Close(); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>

        <span class="cov0" title="0">avatar, err := h.static.UploadStatic(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err = h.applicant.UpdateAvatar(ctx, userID, avatar.ID); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err = json.NewEncoder(w).Encode(avatar); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "ResuMatch/internal/config"
        "ResuMatch/internal/entity"
        "ResuMatch/internal/entity/dto"
        "ResuMatch/internal/middleware"
        "ResuMatch/internal/transport/http/utils"
        "ResuMatch/internal/usecase"
        "encoding/json"
        "net/http"
)

type AuthHandler struct {
        auth usecase.Auth
        cfg  config.CSRFConfig
}

func NewAuthHandler(auth usecase.Auth, cfg config.CSRFConfig) AuthHandler <span class="cov0" title="0">{
        return AuthHandler{auth: auth, cfg: cfg}
}</span>

func (h *AuthHandler) Configure(r *http.ServeMux) <span class="cov0" title="0">{
        authMux := http.NewServeMux()
        authMux.HandleFunc("GET /isAuth", h.IsAuth)
        authMux.HandleFunc("POST /logout", h.Logout)
        authMux.HandleFunc("POST /logoutAll", h.LogoutAll)
        authMux.HandleFunc("POST /emailExists", h.EmailExists)

        r.Handle("/auth/", http.StripPrefix("/auth", authMux))
}</span>

// IsAuth godoc
// @Tags Auth
// @Summary Проверка авторизации
// @Description Проверяет авторизован пользователь или нет.
// @Security session_cookie
// @Produce json
// @Success 200 {object} dto.AuthResponse
// @Failure 401 {object} utils.APIError
// @Failure 500 {object} utils.APIError
// @Router /auth/isAuth [get]
func (h *AuthHandler) IsAuth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(dto.AuthResponse{UserID: userID, Role: role}); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// EmailExists godoc
// @Tags Auth
// @Summary Проверка email
// @Description Проверяет, зарегистрирован ли email в системе
// @Accept json
// @Produce json
// @Param input body dto.EmailExistsRequest true "Email для проверки"
// @Success 200 {object} dto.EmailExistsResponse
// @Failure 400 {object} utils.APIError
// @Failure 403 {object} utils.APIError
// @Failure 404 {object} utils.APIError
// @Failure 500 {object} utils.APIError
// @Router /auth/emailExists [post]
// @Security csrf_token
func (h *AuthHandler) EmailExists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var emailDTO dto.EmailExistsRequest
        err := json.NewDecoder(r.Body).Decode(&amp;emailDTO)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">response, err := h.auth.EmailExists(ctx, emailDTO.Email)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// Logout godoc
// @Tags Auth
// @Summary Выход из системы
// @Description Завершает текущую сессию пользователя
// @Success 200
// @Failure 500 {object} utils.APIError
// @Router /auth/logout [post]
// @Security session_cookie
// @Security csrf_token
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">err = h.auth.Logout(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // очищаем старые cookie
        <span class="cov0" title="0">utils.ClearTokenCookies(w)
        // устанавливаем новый токен
        middleware.SetCSRFToken(w, r, h.cfg)
        w.WriteHeader(http.StatusOK)</span>
}

// LogoutAll godoc
// @Tags Auth
// @Summary Выход со всех устройств
// @Description Завершает все активные сессии пользователя
// @Success 200
// @Failure 404 {object} utils.APIError
// @Failure 500 {object} utils.APIError
// @Router /auth/logoutAll [post]
// @Security session_cookie
// @Security csrf_token
func (h *AuthHandler) LogoutAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err := h.auth.LogoutAll(ctx, userID, role); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // очищаем старые cookie
        <span class="cov0" title="0">utils.ClearTokenCookies(w)
        // устанавливаем новый токен
        middleware.SetCSRFToken(w, r, h.cfg)
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "ResuMatch/internal/config"
        "ResuMatch/internal/entity"
        "ResuMatch/internal/entity/dto"
        "ResuMatch/internal/middleware"
        "ResuMatch/internal/transport/http/utils"
        "ResuMatch/internal/usecase"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
)

type EmployerHandler struct {
        auth     usecase.Auth
        employer usecase.Employer
        static   usecase.Static
        cfg      config.CSRFConfig
}

func NewEmployerHandler(auth usecase.Auth, employer usecase.Employer, static usecase.Static, cfg config.CSRFConfig) EmployerHandler <span class="cov0" title="0">{
        return EmployerHandler{auth: auth, employer: employer, static: static, cfg: cfg}
}</span>

func (h *EmployerHandler) Configure(r *http.ServeMux) <span class="cov0" title="0">{
        employerMux := http.NewServeMux()

        employerMux.HandleFunc("POST /register", h.Register)
        employerMux.HandleFunc("POST /login", h.Login)
        employerMux.HandleFunc("GET /profile/{id}", h.GetProfile)
        employerMux.HandleFunc("PUT /profile", h.UpdateProfile)
        employerMux.HandleFunc("POST /logo", h.UploadLogo)

        r.Handle("/employer/", http.StripPrefix("/employer", employerMux))
}</span>

// Register godoc
// @Tags Employer
// @Summary Регистрация работодателя
// @Accept json
// @Produce json
// @Param registerData body dto.EmployerRegister true "Данные для регистрации"
// @Header 200 {string} Set-Cookie "Сессионные cookies"
// @Header 200 {string} X-CSRF-Token "CSRF-токен"
// @Success 200 {object} dto.AuthResponse
// @Failure 400 {object} utils.APIError "Неверный формат запроса"
// @Failure 409 {object} utils.APIError "Пользователь уже существует"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /employer/register [post]
// @Security csrf_token
func (h *EmployerHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var registerDTO dto.EmployerRegister
        if err := json.NewDecoder(r.Body).Decode(&amp;registerDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrBadRequest)
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("comp=%s, addr=%s", registerDTO.CompanyName, registerDTO.LegalAddress)
        employerID, err := h.employer.Register(ctx, &amp;registerDTO)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err := utils.CreateSession(w, r, h.auth, employerID, "employer"); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">middleware.SetCSRFToken(w, r, h.cfg)

        w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(dto.AuthResponse{UserID: employerID, Role: "employer"}); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// Login godoc
// @Tags Employer
// @Summary Авторизация работодателя
// @Description Авторизация работодателя. При успешной авторизации отправляет куки с сессией.
// Если пользователь уже авторизован, предыдущие cookies с сессией перезаписываются.
// Также устанавливает CSRF-токен при успешной авторизации.
// @Accept json
// @Produce json
// @Param loginData body dto.Login true "Данные для авторизации (email и пароль)"
// @Header 200 {string} Set-Cookie "Сессионные cookies"
// @Header 200 {string} X-CSRF-Token "CSRF-токен"
// @Success 200 {object} dto.AuthResponse
// @Failure 400 {object} utils.APIError "Неверный формат запроса"
// @Failure 403 {object} utils.APIError "Доступ запрещен (неверные учетные данные)"
// @Failure 404 {object} utils.APIError "Пользователь не найден"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /employer/login [post]
// @Security csrf_token
func (h *EmployerHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var loginDTO dto.Login
        if err := json.NewDecoder(r.Body).Decode(&amp;loginDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">employerID, err := h.employer.Login(ctx, &amp;loginDTO)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err := utils.CreateSession(w, r, h.auth, employerID, "employer"); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">middleware.SetCSRFToken(w, r, h.cfg)

        w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(dto.AuthResponse{UserID: employerID, Role: "employer"}); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

// GetProfile godoc
// @Tags Employer
// @Summary Получить профиль работодателя
// @Description Возвращает профиль работодателя по ID. Доступен всем.
// @Produce json
// @Param id path int true "ID работодателя"
// @Success 200 {object} dto.EmployerProfileResponse "Профиль работодателя"
// @Failure 400 {object} utils.APIError "Неверный ID"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 404 {object} utils.APIError "Профиль не найден"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /employer/profile/{id} [get]
func (h *EmployerHandler) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        requestedID := r.PathValue("id")
        employerID, err := strconv.Atoi(requestedID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">employer, err := h.employer.GetUser(ctx, employerID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err = json.NewEncoder(w).Encode(employer); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}

// UpdateProfile godoc
// @Tags Employer
// @Summary Обновить профиль работодателя
// @Description Обновляет данные профиля работодателя, кроме лого. Требует авторизации.
// @Accept json
// @Param updateData body dto.EmployerProfileUpdate true "Данные для обновления профиля"
// @Success 204
// @Failure 400 {object} utils.APIError "Неверный формат данных"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 403 {object} utils.APIError "Нет доступа"
// @Failure 409 {object} utils.APIError "Пользователь уже существует"
// @Failure 500 {object} utils.APIError "Внутренняя ошибка сервера"
// @Router /employer/profile [put]
// @Security csrf_token
// @Security session_cookie
func (h *EmployerHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        // проверяем сессию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if role != "employer" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        <span class="cov0" title="0">var employerDTO dto.EmployerProfileUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;employerDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.employer.UpdateProfile(ctx, userID, &amp;employerDTO); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// UploadLogo godoc
// @Tags Employer
// @Summary Загрузить логотип
// @Description Загружает изображение логотипа для профиля работодателя. Требует авторизации и CSRF-токена.
// @Accept multipart/form-data
// @Produce json
// @Param logo formData file true "Файл изображения (JPEG/PNG, макс. 5MB)"
// @Success 200 {object} dto.UploadStaticResponse "Информация о файле"
// @Failure 400 {object} utils.APIError "Неверный формат файла"
// @Failure 401 {object} utils.APIError "Не авторизован"
// @Failure 403 {object} utils.APIError "Доступ запрещен"
// @Failure 413 {object} utils.APIError "Файл слишком большой"
// @Failure 500 {object} utils.APIError "Ошибка загрузки файла"
// @Router /employer/logo [post]
// @Security session_cookie
// @Security csrf_token
func (h *EmployerHandler) UploadLogo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        cookie, err := r.Cookie("session_id")
        if err != nil || cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if role != "employer" </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        <span class="cov0" title="0">file, _, err := r.FormFile("logo")
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
        <span class="cov0" title="0">if err = file.Close(); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>

        <span class="cov0" title="0">logo, err := h.static.UploadStatic(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err = h.employer.UpdateLogo(ctx, userID, logo.ID); err != nil </span><span class="cov0" title="0">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov0" title="0">if err = json.NewEncoder(w).Encode(logo); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "ResuMatch/internal/config"
        "ResuMatch/internal/entity"
        "ResuMatch/internal/entity/dto"
        "ResuMatch/internal/transport/http/utils"
        "ResuMatch/internal/usecase"
        "ResuMatch/pkg/sanitizer"
        "encoding/json"
        "net/http"
        "strconv"
)

type ResumeHandler struct {
        auth   usecase.Auth
        resume usecase.ResumeUsecase
        cfg    config.CSRFConfig
}

func NewResumeHandler(auth usecase.Auth, resume usecase.ResumeUsecase, cfg config.CSRFConfig) ResumeHandler <span class="cov8" title="1">{
        return ResumeHandler{auth: auth, resume: resume, cfg: cfg}
}</span>

func (h *ResumeHandler) Configure(r *http.ServeMux) <span class="cov8" title="1">{
        resumeMux := http.NewServeMux()

        resumeMux.HandleFunc("POST /create", h.CreateResume)
        resumeMux.HandleFunc("GET /{id}", h.GetResume)
        resumeMux.HandleFunc("PUT /{id}", h.UpdateResume)
        resumeMux.HandleFunc("DELETE /{id}", h.DeleteResume)
        resumeMux.HandleFunc("GET /all", h.GetAllResumes)

        r.Handle("/resume/", http.StripPrefix("/resume", resumeMux))
}</span>

func (h *ResumeHandler) CreateResume(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Проверяем авторизацию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Проверяем, что пользователь - соискатель
        <span class="cov8" title="1">if role != "applicant" </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        // Декодируем запрос
        <span class="cov8" title="1">var createResumeRequest dto.CreateResumeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;createResumeRequest); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        // Санитизация всех полей, которые приходят с фронтенда
        <span class="cov8" title="1">createResumeRequest.AboutMe = sanitizer.StrictPolicy.Sanitize(createResumeRequest.AboutMe)
        createResumeRequest.Specialization = sanitizer.StrictPolicy.Sanitize(createResumeRequest.Specialization)
        createResumeRequest.EducationalInstitution = sanitizer.StrictPolicy.Sanitize(createResumeRequest.EducationalInstitution)

        // Санитизация массивов строк
        for i, skill := range createResumeRequest.Skills </span><span class="cov8" title="1">{
                createResumeRequest.Skills[i] = sanitizer.StrictPolicy.Sanitize(skill)
        }</span>

        <span class="cov8" title="1">for i, spec := range createResumeRequest.AdditionalSpecializations </span><span class="cov8" title="1">{
                createResumeRequest.AdditionalSpecializations[i] = sanitizer.StrictPolicy.Sanitize(spec)
        }</span>

        // Санитизация опыта работы
        <span class="cov8" title="1">for i, we := range createResumeRequest.WorkExperiences </span><span class="cov8" title="1">{
                createResumeRequest.WorkExperiences[i].EmployerName = sanitizer.StrictPolicy.Sanitize(we.EmployerName)
                createResumeRequest.WorkExperiences[i].Position = sanitizer.StrictPolicy.Sanitize(we.Position)
                createResumeRequest.WorkExperiences[i].Duties = sanitizer.StrictPolicy.Sanitize(we.Duties)
                createResumeRequest.WorkExperiences[i].Achievements = sanitizer.StrictPolicy.Sanitize(we.Achievements)
        }</span>

        <span class="cov8" title="1">resume, err := h.resume.Create(ctx, userID, &amp;createResumeRequest)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Отправляем ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(resume); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

func (h *ResumeHandler) GetResume(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Получаем ID резюме из URL
        resumeIDStr := r.PathValue("id")
        resumeID, err := strconv.Atoi(resumeIDStr)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        // Получаем резюме
        <span class="cov8" title="1">resume, err := h.resume.GetByID(ctx, resumeID)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Отправляем ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(resume); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

func (h *ResumeHandler) UpdateResume(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Проверяем авторизацию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Проверяем, что пользователь - соискатель
        <span class="cov8" title="1">if role != "applicant" </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        // Получаем ID резюме из URL
        <span class="cov8" title="1">resumeIDStr := r.PathValue("id")
        resumeID, err := strconv.Atoi(resumeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        // Декодируем запрос
        <span class="cov8" title="1">var updateResumeRequest dto.UpdateResumeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;updateResumeRequest); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        <span class="cov8" title="1">updateResumeRequest.AboutMe = sanitizer.StrictPolicy.Sanitize(updateResumeRequest.AboutMe)
        updateResumeRequest.Specialization = sanitizer.StrictPolicy.Sanitize(updateResumeRequest.Specialization)
        updateResumeRequest.EducationalInstitution = sanitizer.StrictPolicy.Sanitize(updateResumeRequest.EducationalInstitution)

        // Санитизация массивов строк
        for i, skill := range updateResumeRequest.Skills </span><span class="cov0" title="0">{
                updateResumeRequest.Skills[i] = sanitizer.StrictPolicy.Sanitize(skill)
        }</span>

        <span class="cov8" title="1">for i, spec := range updateResumeRequest.AdditionalSpecializations </span><span class="cov0" title="0">{
                updateResumeRequest.AdditionalSpecializations[i] = sanitizer.StrictPolicy.Sanitize(spec)
        }</span>

        // Санитизация опыта работы
        <span class="cov8" title="1">for i, we := range updateResumeRequest.WorkExperiences </span><span class="cov0" title="0">{
                updateResumeRequest.WorkExperiences[i].EmployerName = sanitizer.StrictPolicy.Sanitize(we.EmployerName)
                updateResumeRequest.WorkExperiences[i].Position = sanitizer.StrictPolicy.Sanitize(we.Position)
                updateResumeRequest.WorkExperiences[i].Duties = sanitizer.StrictPolicy.Sanitize(we.Duties)
                updateResumeRequest.WorkExperiences[i].Achievements = sanitizer.StrictPolicy.Sanitize(we.Achievements)
        }</span>

        <span class="cov8" title="1">resume, err := h.resume.Update(ctx, resumeID, userID, &amp;updateResumeRequest)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Отправляем ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(resume); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

func (h *ResumeHandler) DeleteResume(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Проверяем авторизацию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Проверяем, что пользователь - соискатель
        <span class="cov8" title="1">if role != "applicant" </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusForbidden, entity.ErrForbidden)
                return
        }</span>

        // Получаем ID резюме из URL
        <span class="cov8" title="1">resumeIDStr := r.PathValue("id")
        resumeID, err := strconv.Atoi(resumeIDStr)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusBadRequest, entity.ErrBadRequest)
                return
        }</span>

        // Удаляем резюме
        <span class="cov8" title="1">response, err := h.resume.Delete(ctx, resumeID, userID)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        // Отправляем ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}

func (h *ResumeHandler) GetAllResumes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Проверяем авторизацию
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if cookie == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusUnauthorized, entity.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">userID, role, err := h.auth.GetUserIDBySession(ctx, cookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteAPIError(w, utils.ToAPIError(err))
                return
        }</span>

        <span class="cov8" title="1">var resumes []dto.ResumeShortResponse

        if role == "applicant" </span><span class="cov8" title="1">{
                // Получаем список всех резюме соискателя
                resumes, err = h.resume.GetAllResumesByApplicantID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteAPIError(w, utils.ToAPIError(err))
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                // Получаем список всех резюме
                resumes, err = h.resume.GetAll(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        utils.WriteAPIError(w, utils.ToAPIError(err))
                        return
                }</span>
        }

        // Отправляем ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(resumes); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, http.StatusInternalServerError, entity.ErrInternal)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package utils

import (
        "ResuMatch/internal/entity"
        "encoding/json"
        "errors"
        "net/http"
)

type APIError struct {
        Status  int    `json:"status"`
        Message string `json:"message"`
}

var errorToStatus = map[error]int{
        entity.ErrNotFound:      http.StatusNotFound,
        entity.ErrBadRequest:    http.StatusBadRequest,
        entity.ErrUnauthorized:  http.StatusUnauthorized,
        entity.ErrForbidden:     http.StatusForbidden,
        entity.ErrAlreadyExists: http.StatusConflict,
        entity.ErrInternal:      http.StatusInternalServerError,
}

func ToAPIError(err error) APIError <span class="cov0" title="0">{
        var apiError APIError
        var customError entity.Error
        if errors.As(err, &amp;customError) </span><span class="cov0" title="0">{
                apiError.Message = customError.InternalErr().Error()
                svcError := customError.ClientErr()
                if status, found := errorToStatus[svcError]; found </span><span class="cov0" title="0">{
                        apiError.Status = status
                }</span> else<span class="cov0" title="0"> {
                        apiError.Status = http.StatusInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                apiError.Message = "internal server error"
                apiError.Status = http.StatusInternalServerError
        }</span>
        <span class="cov0" title="0">return apiError</span>
}

func WriteError(w http.ResponseWriter, status int, err error) <span class="cov0" title="0">{
        WriteAPIError(w, APIError{
                Status:  status,
                Message: err.Error(),
        })
}</span>

func WriteAPIError(w http.ResponseWriter, apiError APIError) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(apiError.Status)
        err := json.NewEncoder(w).Encode(apiError)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package utils

import (
        "ResuMatch/internal/usecase"
        "net/http"
        "time"
)

func ClearTokenCookies(w http.ResponseWriter) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                Expires:  time.Now().Add(-24 * time.Hour),
                SameSite: http.SameSiteStrictMode,
                MaxAge:   -1,
        })

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "csrf_token",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                Expires:  time.Now().Add(-24 * time.Hour),
                SameSite: http.SameSiteStrictMode,
                MaxAge:   -1,
        })
}</span>

func CreateSession(w http.ResponseWriter, r *http.Request, auth usecase.Auth, userID int, role string) error <span class="cov0" title="0">{
        ctx := r.Context()
        session, err := auth.CreateSession(ctx, userID, role)
        if err != nil </span><span class="cov0" title="0">{
                WriteAPIError(w, ToAPIError(err))
                return err
        }</span>
        <span class="cov0" title="0">expirationTime := time.Now().Add(time.Duration(86400) * time.Second)
        SetSession(w, session, expirationTime)
        return nil</span>
}

func SetSession(w http.ResponseWriter, value string, expires time.Time) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    value,
                Path:     "/",
                Secure:   false,
                HttpOnly: true,
                Expires:  expires,
                SameSite: http.SameSiteStrictMode,
        })
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
